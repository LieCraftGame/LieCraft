<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Deception Game</title>
  <style>
    body {
      background-color: #1b1b32;
      color: #fff;
      font-family: 'Press Start 2P', monospace, sans-serif;
      margin: 0;
      padding: 20px;
      background-size: cover;
    }
    /* Main container styling */
    #main-container {
      max-width: 800px;
      margin: 10% auto;
      border: 2px solid #fff;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
    }
    /* Game Title */
    #game-title {
      margin: 0;
      padding: 10px;
      background-color: #2d2d6f;
      border-bottom: 2px solid #fff;
    }
    /* Tab header styling */
    #tab-header {
      display: flex;
      background-color: #2d2d6f;
      border-bottom: 2px solid #fff;
    }
    .tab-button {
      flex: 1;
      padding: 10px;
      text-align: center;
      cursor: pointer;
      border: 1px solid #fff;
      border-bottom: none;
      background-color: #2d2d6f;
      color: #fff;
    }
    .tab-button.active {
      background-color: #fff;
      color: #1b1b32;
      border-top: 2px solid #fff;
      border-left: 2px solid #fff;
      border-right: 2px solid #fff;
      
    }
    /* Tab content styling */
    .tab-content {
      display: none;
      padding: 10px;
    }
    .tab-content.active {
      display: block;
    }
    .hidden {
        display: none;
    }
    /* Section styling (inside each tab) */
    .section {
      margin-bottom: 20px;
      padding: 10px;
      border: 2px solid #fff;
      background-color: rgba(0, 0, 0, 0.4);
    }
    input, button {
      font-family: 'Press Start 2P', monospace;
      font-size: 0.8rem;
      padding: 5px 10px;
      margin: 5px 0;
      background-color: #2d2d6f;
      border: 2px solid #fff;
      color: #fff;
      cursor: pointer;
    }
    button:hover {
      background-color: #44448f;
    }
    /* Chat windows */
    #lobby-chat-window, #game-chat-window {
      border: 2px solid #fff;
      padding: 10px;
      height: 150px;
      overflow-y: scroll;
      background-color: #000;
    }
    /* Player list images */
    .pfp {
      width: 30px;
      height: 30px;
      margin-right: 5px;
      vertical-align: middle;
    }
    /* Horizontal players list in Game tab */
    #game-player-list {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
    }
    #game-player-list > div {
        display: inline-flex;
        align-items: center;
    }
    #show-lobbies-btn {
        /*position: absolute;*/
        bottom: 10px;
        right: 10px;
    }
    #enter-game-btn.ready {
      background-color: #4CAF50;  /* green background */
      border-color: #4CAF50;
      color: #fff;
    }
    /* Lobbies info display styling */
    #lobbies-info {
        margin-top: 10px;
        background-color: rgba(0, 0, 0, 0.8);
        padding: 10px;
        border: 2px solid #fff;
        white-space: pre-wrap;
    }
    /* Avatar selection */
    .avatar {
      width: 50px;
      height: 50px;
      margin: 5px;
      cursor: pointer;
      border: 2px solid transparent;
    }
    .avatar.selected {
      border-color: #fff;
    }
    #avatar-selection {
      max-width: 300px;
      margin-left: 0 auto;
    }
    #lobby-ready.selected {
      background-color: #4CAF50;  /* green */
      border-color: #4CAF50;
      color: #fff;
    }
    #game-role-cooperator.selected {
      background-color: #4c82af;  
      border-color: #4cadaf;
      color: #fff;
    }
    #game-role-defector.selected {
      background-color: #4c82af;  
      border-color: #4cadaf;
      color: #fff;
    }
    /* #game-role-jester.selected {
      background-color: #4c82af;  
      border-color: #4cadaf;
      color: #fff;
    }*/
    #hand-overlay {
      display: none;
      position: fixed;
      top:0; left:0;
      width:100%; height:100%;
      background: rgba(0,0,0,0.8);
      z-index: 1001;
      display: flex;               /* make it flex container */
      align-items: center;
      justify-content: center;
    }
    #hand-options img {
      cursor: pointer;
      width: 60px;
      margin: 0 5px;
    }
    #hand-options img.selected {
      border: 2px solid #4CAF50;
      border-radius: 4px;
    }
    /* Hand section styling in Game tab */
    #hand-section {
        margin-top: 20px;
        /* text-align: center; */
    }
    #hand-display img {
        width: 50px;
        margin: 5px;
    }
    #hand-display img {
      cursor: pointer;
    }
    #hand-display img.selected {
      border: 2px solid #4CAF50;
      border-radius: 4px;
    }
    .hand-card-coop {
      border: 3px solid #4CAF50;
      border-radius: 4px;
    }
    
    .hand-card-def {
      border: 3px solid #f44336;
      border-radius: 4px;
    }
    /* Role selection section */
    #role-selection-section {
        text-align: center;
        margin-top: 10px;
    }
    #game-role-selection button {
        margin: 5px;
    }
    #game-role-selection button.selected {
      background-color: #4c82af;  /* green */
      border-color: #4cadaf;
      color: #fff;
    }
    /* AI‑avatar grid */
    #ai-player-config {
      display: none;
      margin-top: 20px;
    }
    .ai-avatar {
      width: 60px;
      height: 60px;
      margin: 8px;
      border: 2px solid transparent;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
      flex-direction: column;
      font-size: 0.6rem;
    }
    .ai-avatar.selected {
      border-color: #4CAF50;
      background-color: rgba(76,194,175,0.2);
    }
    .ai-controls {
      margin-top: 5px;
      text-align: center;
    }
    .ai-slider {
      width: 100%;
      margin-top: 5px;
    }
    /* Retreat Vote Overlay Details */
    #retreat-overlay {
      display: none;
      position: fixed;
      top:   0; left:  0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.8);
      z-index: 1002;
      align-items: center;
      justify-content: center;
    }
    #retreat-overlay .content {
      background: #1b1b32;
      color:      #fff;
      padding:    20px;
      border:     2px solid #fff;
      border-radius: 8px;
      text-align: center;
      max-width:  400px;
    }
    #retreat-cards {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 10px 0;
    }
    .retreat-card {
      width: 40px;
      border-radius: 4px;
    }
    .retreat-card.coop { 
      border: 2px solid #4CAF50; 
    }
    .retreat-card.def  { 
      border: 2px solid #f44336; 
    }
    #hand-decision-content h2 {
      white-space: pre-wrap;
    }
    #turn-indicator {
      font-size: 1rem;
      text-align: center;
    }
    
    #reveal-hand-btn {
      padding: 8px 16px;
      font-size: 0.9rem;
      margin: 0 auto;
      display: block;
      border: 2px solid #4CAF50;
      border-radius: 4px;
      position: relative;
    }
    /* pulsing glow */
    #reveal-hand-btn.glow {
      animation: pulse-glow 1s infinite alternate;
    }
    
    @keyframes pulse-glow {
      from {
        box-shadow: 0 0 5px rgba(76, 175, 80, 0.6);
      }
      to {
        box-shadow: 0 0 20px rgba(76, 175, 80, 1);
      }
    }
  </style>
</head>
<body>
  <div id="main-container">
    <h1 id="game-title">Deception Game</h1>
    
    <!-- Tab Header -->
    <div id="tab-header">
      <div class="tab-button active" onclick="showTab('login')">Login</div>
      <div class="tab-button" onclick="showTab('lobby')">Lobby</div>
      <div class="tab-button" onclick="showTab('game')">Game</div>
    </div>
    
    <!-- Tab Contents -->
    <div id="tab-login" class="tab-content active">
      <div class="section">
        <h2>Join or Start a Lobby</h2>
        <input type="text" id="lobby-name" placeholder="Lobby Name"><br>
        <input type="password" id="lobby-password" placeholder="Password"><br>
        <input type="text" id="username" placeholder="Username"><br>
        <!-- Avatar Selection -->
        <div id="avatar-selection" class="section">
          <div id="avatar-options">
            <img src="assets/alice.png" alt="alice" class="avatar" onclick="selectAvatar('alice')">
            <img src="assets/bob.png" alt="bob" class="avatar" onclick="selectAvatar('bob')">
            <img src="assets/charlie.png" alt="charlie" class="avatar" onclick="selectAvatar('charlie')">
            <img src="assets/neale.png" alt="neale" class="avatar" onclick="selectAvatar('neale')">
          </div>
        </div>
        <button onclick="joinLobby()">Join / Start Lobby</button>
        <button id="show-lobbies-btn" onclick="showLobbies()">Show Lobbies</button>
        <div id="lobbies-info" class="hidden"></div>
        <!-- Add AI Player Button -->
        <button id="add-ai-player-btn" style="position: absolute; bottom: 40px; right: 20px;" onclick="showAddAIPlayerUI()">AI Players</button>

        <!-- Hidden container to input AI URL and trigger addBot() 
        <div id="add-ai-player-container" style="display:none; position:absolute; bottom: 85px; right: 20px; background-color:#2d2d6f; padding: 10px; border:2px solid #fff; border-radius: 8px;">
          <input type="text" id="ai-url" placeholder="AI URL" style="font-family: 'Press Start 2P', monospace; font-size: 0.8rem; padding: 5px; margin-bottom: 5px; border:2px solid #fff; background-color:#2d2d6f; color:#fff;">
          <br>
          <button onclick="addBot()">Add</button>
        </div> -->
        <div id="ai-player-config" class="section">
          <h3>Select & Configure AI</h3>
          <!-- model grid -->
          <div id="ai-avatar-grid" style="display:flex; flex-wrap:wrap;"></div>
          <!-- controls below the grid -->
          <div id="ai-controls-area" style="display:none; margin-top:10px;">
            <input type="text" id="ai-url" placeholder="Server URL" style="width:100%;"><br>
            <input type="text" id="ai-apiKey" placeholder="API Key" style="width:100%;"><br>
            <input type="text" id="ai-sysprompt" placeholder="System Prompt" style="width:100%;"><br>

            <button id="ai-add-btn" style="margin-right:10px;">Add AI</button>
            <button id="ai-configure-btn">Configure</button><br>
            <input type="range" id="ai-temp-slider" class="ai-slider" min="0" max="1" step="0.01" style="display:none; width:100%; margin-top:5px;">
            <div id="ai-temp-label" style="font-size:0.6rem; display:none; text-align:center;">Temp: 0.7</div>
          </div>
        </div>
      </div>
    </div>
    
    <div id="tab-lobby" class="tab-content">
      <div class="section">
        <h2>Lobby</h2>
        <div id="lobby-status">Lobby: no lobby joined</div>
      </div>
      <div class="section">
        <h3>Chat</h3>
        <div id="lobby-chat-window"></div>
        <input type="text" id="chat-input" placeholder="Type your message">
        <button onclick="sendLobbyChat()">Send</button>
      </div>
      <div class="section">
        <h3>Players</h3>
        <div id="player-list"></div>
      </div>
      <h3>Ready</h3>
      <!-- Role selection UI only for the current player -->
      <div id="ready-up-role-selection-section">
        <!--
        <button id="role-cooperator" onclick="selectRoleChoice('cooperator')">Cooperator</button>
        <button id="role-defector" onclick="selectRoleChoice('defector')">Defector</button>
        <button id="role-jester" onclick="selectRoleChoice('jester')">Jester</button>
        <br> -->
        <button id="lobby-ready" onclick="readyUp()">Ready Up</button>
      </div>
    <!--</div>-->
      <div class="section">
        <h3>Mission</h3>
        <div id="game-state-lobby">Phase: Waiting for game to start...</div>
        <button id="enter-game-btn" onclick="startGame(false)" disabled>Enter Game</button>
      </div>
    </div>
    
    <div id="tab-game" class="tab-content">
      <div class="section">
        <h3>Players</h3>
        <div id="game-player-list"></div>
        <div id="mission-event-display" style="margin-top:10px; text-align:left; font-weight:bold;">
            Mission: 1, Event: 1
        </div>
      </div>
      <div class="section">
        <h3>Chat</h3>
        <div id="game-chat-window"></div>
        <input type="text" id="game-chat-input" placeholder="Type your message">
        <button onclick="sendGameChat()">Send</button>
      </div>
      <div class="section" id="game-role-selection">
        <h3>Select Your Role</h3>
        <button id="game-role-cooperator" onclick="selectRoleChoice('cooperator')">Cooperator</button>
        <button id="game-role-defector" onclick="selectRoleChoice('defector')">Defector</button>
        <!--<button id="game-role-jester" onclick="selectRoleChoice('jester')">Jester</button>-->
        <button id="game-role-lockin" onclick="selectRoleLock()">Lock Role</button>

      </div>
      <div class="section">
        <h3>Game State</h3>
        <div id="game-state-display">Phase: Waiting for event</div>
        <div id="nomination-ui-container"></div>
        <div id="voting-ui-container"></div>
        <div id="hidden-event-display" style="display: none;"></div>

        <!--<button onclick="revealEvent()">Draw Event</button>-->
      </div>

      <div id="hand-section" class="section" style="display: flex; justify-content: space-between; align-items: flex-start;">
        <div id="hand-available">
          <h3>Play Area</h3>
          <div id="hand-display" style="display: none;"></div>
        
          <!-- turn indicator + reveal button -->
          <div id="turn-indicator" style="margin: 10px 0; font-size: 1rem;"></div>
            <button id="reveal-hand-btn" onclick="onRevealHandClick()" style="display: none;">Reveal Hand</button>
          </div>
        <div id="last-played-container" style="text-align: center; margin-left: 20px;">
          <h4>Played Cards</h4>
          <div id="last-played-card" style="display: none; background-color: #4c82af; border: 2px solid #4cadaf; padding: 5px;"></div>
        </div>
      </div>
    </div>
    
    <!-- Place this at the end of your body -->
    <audio id="theme-audio" src="assets/theme.mp3" loop></audio>
    <div id="audio-controls" style="position: fixed; bottom: 10px; right: 10px;">
      <button id="audio-toggle" onclick="toggleAudio()">Pause</button>
    </div>
  </div>
  <!-- Hand Decision Overlay -->
  <div id="hand-overlay" style="display:none;"">
    <div id="hand-decision-content"
          style="background:#1b1b32; color:#fff; padding:20px;
                border:2px solid #fff; border-radius:8px;
                text-align:center; max-width:400px;">
    <h2>Select a card to play or discard</h2>
    <div id="hand-options" 
          style="display:flex; justify-content:center; flex-wrap:wrap; gap:10px; margin:20px 0;">
          <!-- cards will be injected here -->
    </div>

    <button id="hand-play-btn">Play</button>
    <button id="hand-discard-btn">Discard</button>
  </div>
  </div>
  <!-- Event Over Overlay-->
  <div id="event-overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background: rgba(0, 0, 0, 0.8); z-index:1000; align-items:center; justify-content:center;">
    <div id="event-overlay-content" style="background:#1b1b32; color:#fff; padding:20px; border:2px solid #fff; border-radius:8px; text-align:center; max-width:600px; margin:auto;">
      <h2>Event Summary</h2>
      <div id="event-summary" style="margin-top:10px; font-size:0.9rem;">
        <!-- Event summary details go here -->
      </div>
      <button id="continue-event-btn" style="margin-top:20px;">Continue</button>
    </div>
  </div>
  <!-- Mission Over overlay window -->
  <div id="mission-overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.8); z-index:1000; align-items: center; justify-content: center;">
    <div id="mission-overlay-content" style="background:#1b1b32; color:#fff; padding:20px; border:2px solid #fff; border-radius:8px; text-align:center; max-width:600px; margin: auto;">
      <h2>New Mission Details</h2>
      <div id="mission-text">[Mission text]</div>
      <div id="payoff-matrix" style="margin-top:10px;"> </div>
      <button id="enter-mission-btn" style="margin-top:20px;">Enter</button>
    </div>
  </div>
  <!-- Retreat Vote Overlay -->
  <div id="retreat-overlay">
    <div class="content">
      <h2>Do you want to Retreat?</h2>
      <div id="retreat-summary">Retreating terminates the mission and the party heads to a vote.<br><br>Cards played this round:</div>
      <div id="retreat-cards"><!-- images go here --></div>
      <button id="retreat-btn">Retreat</button>
      <button id="keepgoing-btn">Keep Going</button>
    </div>
  </div>
  <!-- Game over overlay window -->
  <div id="gameover-overlay" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; align-items: center; justify-content: center;">
    <div id="gameover-overlay-content" style="background: #1b1b32; color: #fff; padding: 20px; border: 2px solid #fff; border-radius: 8px; text-align: center; max-width: 600px; margin: auto;">
      <h2>Game Over!</h2>
      <div id="gameover-summary" style="margin-top: 10px; font-size: 0.9rem;">
        <!-- Final summary (missions, scores, etc.) will be inserted here -->
      </div>
      <div style="margin-top: 20px;">
        <button onclick="backToLobby()" style="margin-right:10px;">Back to Lobby</button>
        <button onclick="startNewGame()">Start New Game</button>
      </div>
    </div>
  </div>

  <script>
    // TAB SWITCHING
    function showTab(tabName) {
      const tabs = document.querySelectorAll('.tab-content');
      tabs.forEach(tab => tab.classList.remove('active'));
      const buttons = document.querySelectorAll('.tab-button');
      buttons.forEach(btn => btn.classList.remove('active'));
      document.getElementById('tab-' + tabName).classList.add('active');
      // Activate corresponding tab button:
      document.querySelector(`#tab-header .tab-button:nth-child(${tabName === 'login' ? 1 : (tabName === 'lobby' ? 2 : 3)})`).classList.add('active');
    }
    
    // GLOBAL VARIABLES
    let lobbyName = "";
    let userName = "";
    let lobbyPassword = "";
    let selectedAvatar = "";
    let players = []; // list of player objects from the backend
    let currentRole = ""; // private role choice for the current player
    let rolesSet = false;
    let selectedCard = "";
    let is_ready = "";
    let missionNum = 1;
    let totalMissions = 1;
    let eventNum = 1;
    let alertedLastEvent = false;
    let alertedLastMission = false;
    let alertedGameOver = false;
    let alertedRetreat = false;
    let alertedNomination = false;
    let alertedLastMissionOver = false;
    let is_ai_player = false;
    let userURL = "";
    let systemPrompt = "";
    let temperature = 1.0;
    let modelName = "";
    let justDiscarded = false;
    let cardPlayed = false;
    let turnPlayer = null;
    let lastChatCount = 0;
    let selectedModel = null, selectedTemp = 0.7;
    const avatarNames = ['alice', 'bob', 'charlie', 'neale',"o3-mini","o4-mini","gpt-4.1","gpt-4.5","gpt-4o","claude-3.7","claude-3.5","gemma2","gemma3","gemini-2.5","gemini-2","gemini-2.5","olmo-2","deephermes3","qwen-2","qwen-2.5","qwq","grok-2","grok-3","mistral-small","mistral-large","llama-3.1","llama-3.3","llama-4","deepseek-r1","deepseek-distilled",];
    const cardImageMap = {
      'a': 'assets/ring.png',
      'b': 'assets/star.png',
      'c': 'assets/x.png',
      'd': 'assets/plus.png',
      'e': 'assets/orb.png',
    };
    const cardAttrMap = {
      "a": "Strength",
      "b": "Agility",
      "c": "Intellect",
      "d": "Wisdom",
      "e": "Charisma"
    };
    let _selectedHandCard = null;
    
    function reset_frontend_newgame() {
        console.log("Resetting frontend for new game");
        currentRole = "";
        selectedCard = "";
        missionNum = 1;
        eventNum = 1;
        totalEvents = 1;
        totalMissions = 1;
        // Reset alert flags
        console.log("Resetting alert flags");
        alertedLastEvent = false;
        alertedLastMission = false;
        alertedLastMissionOver = false;
        alertedGameOver = false;
        document.getElementById("game-role-selection").style.display = "";
        rolesSet = false;
        document.getElementById("mission-event-display").innerText =  "Mission: " + missionNum + " / " + totalMissions + ",  Event: " + eventNum + " / " + totalEvents;
        
        const lastPlayedDiv = document.getElementById("last-played-card");
        lastPlayedDiv.innerHTML = "";  // clear previous contents
        lastPlayedDiv.style.display = "none";
        // hide hand and enable show hand button
        document.getElementById("hand-display").style.display = "none";
        document.getElementById("reveal-hand-btn").style.display = "";
        document.getElementById("game-role-cooperator").classList.remove("selected");
        document.getElementById("game-role-defector").classList.remove("selected");
        //document.getElementById("game-role-jester").classList.remove("selected");
        document.getElementById("lobby-ready").classList.remove("selected");
        updatePlayerList();

    }
    // AVATAR SELECTION
    function selectAvatar(avatarName) {
      selectedAvatar = avatarName;
      const avatars = document.querySelectorAll('.avatar');
      avatars.forEach(avatar => {
        if (avatar.alt.toLowerCase() === avatarName.toLowerCase()) {
          avatar.classList.add('selected');
        } else {
          avatar.classList.remove('selected');
        }
      });
    }
    // ROLE SELECTION 
    function selectRoleChoice(role) {
        currentRole = role;
        // Remove "selected" class from all role buttons
        document.getElementById("game-role-cooperator").classList.remove("selected");
        document.getElementById("game-role-defector").classList.remove("selected");
        //document.getElementById("game-role-jester").classList.remove("selected");
        // Add "selected" class to the clicked button
        if (role === "cooperator") {
            document.getElementById("game-role-cooperator").classList.add("selected");
        } else if (role === "defector") {
            document.getElementById("game-role-defector").classList.add("selected");
        } //else if (role === "jester") {
        //    document.getElementById("game-role-jester").classList.add("selected");
        //}
    }

    function selectRoleLock() {  
      if (!currentRole) {
        alert("Please select a role before readying up.");
        return;
      }
      fetch("http://127.0.0.1:8008/set_player_role", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({
          lobby_name: lobbyName,
          username: userName,
          role: currentRole
        })
      })
      .then(response => {
        if (!response.ok) throw new Error("Failed to set role.");
        return response.json();
      })
      .then(data => {
        // Hide the role selection UI once ready
        document.getElementById("game-role-selection").style.display = "none";
        rolesSet = true;
        // alert("Role set to " + currentRole + ". You are ready!");
        // advanceEvent()
      })
      .catch(error => {
        console.error(error);
        alert(error);
      });
    }
    // JOIN LOBBY
    function generateUsername() {
      const adjectives = ['Cool', 'Fast', 'Clever', 'Brave', 'Happy', 'Mighty', 'Witty', 'Lucky'];
      const nouns = ['Tiger', 'Falcon', 'Ninja', 'Wizard', 'Robot', 'Dragon', 'Panda', 'Knight'];
      const randomAdjective = adjectives[Math.floor(Math.random() * adjectives.length)];
      const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];
      const randomNumber = Math.floor(Math.random() * 1000); // From 0 to 999
      return `${randomAdjective}${randomNoun}${randomNumber}`;
    }
    
    function showAddAIPlayerUI() {
      let container = document.getElementById("add-ai-player-container");
      // Toggle visibility
      if (container.style.display === "none" || container.style.display === "") {
        container.style.display = "block";
      } else {
        container.style.display = "none";
      }
    }
    function addBot(selectedModel, selectedTemp, apiKey, systemPrompt, userURL) {
        console.log("Adding AI player:", modelName, "with temp", temperature);
        lobbyName = document.getElementById("lobby-name").value.trim();
        lobbyPassword = document.getElementById("lobby-password").value.trim();
        userName = generateUsername();
        // const avatarNames = ['alice', 'bob', 'charlie', 'neale', 'openai', 'google', 'qwen', 'grok', 'deepseek', 'meta'];
        // const randomIndex = Math.floor(Math.random() * avatarNames.length);
        // const Avatar = avatarNames[randomIndex];
        selectedAvatar = selectedModel
        selectAvatar(selectedAvatar);
        // selectedAvatar = sele;
        if (!userURL) {
          alert("Please enter an AI URL.");
          return;
        }
        // Debug log the payload:
        console.log("Adding bot with payload:", {
            lobby_name: lobbyName,
            username: userName,
            password: lobbyPassword,
            avatar: selectedAvatar,
            url: userURL,
            model_name: modelName,
            temperature: temperature,
            system_prompt: systemPrompt,
            api_key: apiKey
        });
        fetch("http://127.0.0.1:8008/add_bot", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({
                lobby_name: lobbyName,
                username: userName,
                password: lobbyPassword,
                avatar: selectedAvatar,
                url: userURL,
                model_name: selectedModel,
                temperature: temperature,
                api_key: apiKey,
                system_prompt: systemPrompt
            })
        })
        .then(response => {
            if (!response.ok) {
                if (response.status === 404) {
                    return fetch("http://127.0.0.1:8008/create_lobby", {
                        method: "POST",
                        headers: {"Content-Type": "application/json"},
                        body: JSON.stringify({
                          lobby_name: lobbyName,
                          password: lobbyPassword
                        })
                    }).then(res => {
                        if (!res.ok) throw new Error("Failed to create lobby.");
                        return res.json();
                    }).then(() => {
                        console.log('created lobby')
                        return fetch("http://127.0.0.1:8008/add_bot", {
                            method: "POST",
                            headers: {"Content-Type": "application/json"},
                            body: JSON.stringify({
                              lobby_name: lobbyName,
                              username: userName,
                              password: lobbyPassword,
                              avatar: selectedAvatar,
                              url: userURL,
                              model_name: selectedModel,
                              temperature: temperature,
                              api_key: apiKey,
                              system_prompt: systemPrompt
                            })
                        });
                    });
                } else {
                    throw new Error("Error joining lobby.");
                }
            }
            return response.json();
        })
        .then(data => {
          console.log(data);
          document.getElementById("lobby-status").innerText = "Lobby Name: " + lobbyName;
          showTab("lobby");
          setInterval(pollLobbyChat, 2000);
          setInterval(pollLobbyState, 2000);
          setInterval(updatePlayerList, 3000);
        })
        .catch(error => {
            console.error(error);
            if (error.message.indexOf("Bot already in lobby") !== -1) {
                alert("Username Taken!");
            } else {
                alert(error);
            }
        });  
    }

    function joinLobby() {
        lobbyName = document.getElementById("lobby-name").value.trim();
        lobbyPassword = document.getElementById("lobby-password").value.trim();
        userName = document.getElementById("username").value.trim();
        if (!lobbyName || !lobbyPassword || !userName) {
            alert("Please enter lobby name, password, and username.");
            return;
        }
        if (!selectedAvatar) {
            alert("Please select an avatar.");
            return;
        }
        
        fetch("http://127.0.0.1:8008/join_lobby", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({
                lobby_name: lobbyName,
                username: userName,
                password: lobbyPassword,
                avatar: selectedAvatar,
                url: userURL
            })
        })
        .then(response => {
          if (!response.ok) {
            if (response.status === 404) {
              return fetch("http://127.0.0.1:8008/create_lobby", {
                  method: "POST",
                  headers: {"Content-Type": "application/json"},
                  body: JSON.stringify({
                      lobby_name: lobbyName,
                      password: lobbyPassword
                  })
              }).then(res => {
                  if (!res.ok) throw new Error("Failed to create lobby.");
                  return res.json();
              }).then(() => {
                return fetch("http://127.0.0.1:8008/join_lobby", {
                    method: "POST",
                    headers: {"Content-Type": "application/json"},
                    body: JSON.stringify({
                        lobby_name: lobbyName,
                        username: userName,
                        password: lobbyPassword,
                        avatar: selectedAvatar,
                        url: userURL
                    })
                });
              });
            } else {
              throw new Error("Error joining lobby.");
            }
          }
          return response.json();
        })
        .then(data => {
            console.log(data);
            document.getElementById("lobby-status").innerText = "Lobby Name: " + lobbyName;
            showTab("lobby");
            setInterval(pollLobbyChat, 2000);
            setInterval(pollLobbyState, 2000);
            setInterval(updatePlayerList, 3000);
        })
        .catch(error => {
            console.error(error);
            if (error.message.indexOf("User already in lobby") !== -1) {
              alert("Username Taken!");
            } else {
              alert(error);
            }
        });
    }
    // Function to fetch and display lobby info from the server
    function showLobbies() {
        fetch("http://127.0.0.1:8008/lobbies")
        .then(response => {
            if (!response.ok) throw new Error("Failed to fetch lobbies.");
            return response.json();
        })
        .then(data => {
            const lobbiesDiv = document.getElementById("lobbies-info");
            lobbiesDiv.classList.remove("hidden");
            lobbiesDiv.innerHTML = "<pre>" + JSON.stringify(data, null, 2) + "</pre>";
        })
        .catch(error => {
            console.error(error);
            alert(error);
        });
    }
    // UPDATE PLAYER LIST (for Lobby and Game tabs)
    function quitGame() {
        if (typeof pollGameChatInterval !== 'undefined') {
          clearInterval(pollGameChatInterval);
        }
        if (typeof pollGameStateInterval !== 'undefined') {
          clearInterval(pollGameStateInterval);
        }          
        let audio = document.getElementById("theme-audio");
        if (audio) {
          audio.pause();
          audio.currentTime = 0;
        }
        document.getElementById("game-state-display").innerHTML = "Game stopped. Returning to Lobby.";
        let missionOverlay = document.getElementById("mission-overlay");
        if (missionOverlay) {
          missionOverlay.style.display = "none";
        }
        let votingUI = document.getElementById("voting-ui-container");
        if (votingUI) {
          votingUI.innerHTML = "";
        }
        let nominationUI = document.getElementById("nomination-ui-container");
        if (nominationUI) {
          nominationUI.innerHTML = "";
        }
        let gameChat = document.getElementById("game-chat-window");
        if (gameChat) {
          gameChat.innerHTML = "";
        }
        document.getElementById("lobby-ready").classList.remove("selected");
        const enterBtn = document.getElementById("enter-game-btn");
        enterBtn.disabled = true;
        enterBtn.classList.remove("ready");
        showTab("lobby");
        updatePlayerList();
        fetch("http://127.0.0.1:8008/stop_game", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({
              lobby_name: lobbyName,
              username: userName,
            })
        })
        .then(response => {
          if (!response.ok) {
            throw new Error("Failed to stop game on the server.");
          }
          return response.json();
        })
        .then(data => {
          console.log("Game successfully stopped:", data);
        })
        .catch(error => console.error(error));
    }

    function readyUp() {  
      fetch("http://127.0.0.1:8008/lobby_ready", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({
          lobby_name: lobbyName,
          username: userName,
        })
      })
      .then(response => {
        if (!response.ok) throw new Error("Failed to set readiness.");
        document.getElementById("lobby-ready").classList.add("selected");
        return response.json();
      })
      .then(data => {
          console.log('Lobby ready: ' + data.message);
      })
      .catch(error => {
        console.error(error);
        alert(error);
      });
    }
    function updatePlayerList() {
        fetch("http://127.0.0.1:8008/lobbies")
        .then(response => {
          if (!response.ok) throw new Error("Failed to fetch lobbies.");
          return response.json();
        })
        .then(data => {
          if (data.lobbies[lobbyName]) {
            players = data.lobbies[lobbyName].players;
            const listDiv = document.getElementById("player-list");
            listDiv.innerHTML = "";
            players.forEach(player => {
              let displayName = player.username;
              let avatarKey = player.avatar ? player.avatar : player.username.toLowerCase();
              let assetName = "assets/" + avatarKey + ".png";
              let leaderMark = player.is_leader ? " (Leader)" : "";
              let roleText = ""
              if (displayName == userName) {
                roleText = player.role ? " (" + player.role + ")" : "";
              }
              is_ai_player = player.is_llm;
              const pDiv = document.createElement("div");
              pDiv.style.display = "inline-flex";
              pDiv.style.alignItems = "center";
              pDiv.style.marginRight = "10px";
              pDiv.innerHTML = `<img class="pfp" src="${assetName}" alt="${displayName}"> ${displayName}${roleText}${leaderMark}`;
              listDiv.appendChild(pDiv);
            });
            const gameListDiv = document.getElementById("game-player-list");
            gameListDiv.innerHTML = "";
            players.forEach(player => {
              let displayName = player.username;
              let avatarKey = player.avatar ? player.avatar : player.username.toLowerCase();
              let assetName = "assets/" + avatarKey + ".png";
              let leaderMark = player.is_leader ? " (Leader)" : "";
              let scoreText = ""
              let roleText = ""
              if (displayName == userName) {
                  scoreText = player.score ? "<br>Score: " + player.score : " Score: 0";
                  roleText = player.role ? " (" + player.role + ")" : "";
              }
              is_ai_player = player.is_llm;
              const gpDiv = document.createElement("div");
              gpDiv.style.display = "inline-flex";
              gpDiv.style.alignItems = "center";
              gpDiv.style.marginRight = "10px";
              gpDiv.innerHTML = `<img class="pfp" src="${assetName}" alt="${displayName}"> ${displayName}${roleText}${leaderMark}${scoreText}`;
              gameListDiv.appendChild(gpDiv);
            });
            // Enable and highlight the "Enter Game" button only if every player has a role.
            let allReady = players.every(player => player.lobby_ready === true);
            document.getElementById("enter-game-btn").disabled = !allReady;
            const enterBtn = document.getElementById("enter-game-btn");
            if (allReady) {
                enterBtn.disabled = false;
                enterBtn.classList.add("ready");
            } else {
                enterBtn.disabled = true;
                enterBtn.classList.remove("ready");
            }
          }
        })
        .catch(error => {
          console.error(error);
        });
      }

    function addChatMessage(message) {
        const chatWindow = document.getElementById("lobby-chat-window");
        chatWindow.innerHTML += message + "<br>";
        chatWindow.scrollTop = chatWindow.scrollHeight;
    }
    function addGameMessage(message) {
        const chatWindow = document.getElementById("game-chat-window");
        chatWindow.innerHTML += message + "<br>";
        chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    // POLL CHAT (for Lobby tab)
    function pollLobbyChat() {
      fetch("http://127.0.0.1:8008/get_lobby_message", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({
          lobby_name: lobbyName,
          password: lobbyPassword
        })
      })
      .then(response => {
        if (!response.ok) throw new Error("Failed to fetch chat.");
        return response.json();
      })
      .then(data => {
        const chatWindow = document.getElementById("lobby-chat-window");
        chatWindow.innerHTML = "";
        data.chat.forEach(item => {
          chatWindow.innerHTML += item.username + ": " + item.message + "<br>";
        });
        chatWindow.scrollTop = chatWindow.scrollHeight;
      })
      .catch(error => {
        console.error(error);
      });
    }
    function pollGameChat() {
        fetch("http://127.0.0.1:8008/get_game_message", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                lobby_name: lobbyName,
                password: lobbyPassword
            })
        })
        .then(response => {
            if (!response.ok) throw new Error("Failed to fetch chat.");
            return response.json();
        })
        .then(data => {
            const chatWindow = document.getElementById("game-chat-window");
            const hist = (data.chat) || [];
            if (hist.length < lastChatCount) {
              lastChatCount = 0;
            }
            const newEntries = hist.slice(lastChatCount);
            newEntries.forEach(entry => {
                // find the username by pid (assuming updatePlayerList set a global `players` array)
                const name   = entry.username
                chatWindow.innerHTML += `<strong>${name}:</strong> ${entry.message}<br>`;
            });
            if (newEntries.length) {
                // scroll & bump our counter
                chatWindow.scrollTop = chatWindow.scrollHeight;
                lastChatCount = hist.length;
            }
        })
        .catch(console.error);
    }
    function addAIChatMessage(username, message) {
        const chatWindow = document.getElementById("game-chat-window");
        const messageDiv = document.createElement("div");
        messageDiv.innerHTML = `<strong>${username}:</strong> ${message}`;
        chatWindow.appendChild(messageDiv);
        chatWindow.scrollTop = chatWindow.scrollHeight;
    }
    // SEND CHAT (Lobby tab)
    function sendLobbyChat() {
      const input = document.getElementById("chat-input");
      const message = input.value.trim();
      if (!message) return;
      fetch("http://127.0.0.1:8008/add_lobby_message", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({
          lobby_name: lobbyName,
          username: userName,
          password: lobbyPassword,
          message: message
        })
      })
      .then(response => {
        if (!response.ok) throw new Error("Failed to send message.");
        return response.json();
      })
      .then(data => {
        input.value = "";
      })
      .catch(error => {
        console.error(error);
        alert(error);
      });
    }
    // SEND CHAT (game tab)
    function sendGameChat() {
        const input = document.getElementById("game-chat-input");
        const message = input.value.trim();
        if (!message) return;
        fetch("http://127.0.0.1:8008/add_game_message", {
          method: "POST",
          headers: {"Content-Type": "application/json"},
          body: JSON.stringify({
            lobby_name: lobbyName,
            username: userName,
            password: lobbyPassword,
            message: message
          })
        })
        .then(response => {
          if (!response.ok) throw new Error("Failed to send message.");
          return response.json();
        })
        .then(data => {
          input.value = "";
        })
        .catch(error => {
          console.error(error);
          alert(error);
        });
      }

    function startGame(restartGame) {
      if (!players.every(player => player.lobby_ready && player.lobby_ready === true)) {
          alert("Not everyone is ready. Please wait until all players have readied up.");
          return;
      }
      fetch("http://127.0.0.1:8008/start_game", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ lobby_name: lobbyName, restart: restartGame })
      })
      .then(response => {
        console.log(response)
        if (!response.ok) throw new Error("Failed to start game: "+response);
        return response.json();
      })
      .then(data => {
        console.log(data);
        /* document.getElementById("game-status").innerText = "Game: Lobby " + lobbyName + " active"; */
        updatePlayerList();
        pollGameChatInterval = setInterval(pollGameChat, 1000); // reusing the same polling for now
        document.getElementById("game-state-display").innerText = "Phase: Waiting for event";
        pollGameStateInterval = setInterval(pollGameState, 1000); // reusing the same polling for now
        showTab("game"); 

        let missionText = data.mission_text || "No mission yet.";
        // Show the overlay with mission text and payoff matrix:
        showMissionOverlay(missionText, true);
        //let audio = document.getElementById("theme-audio");
        //if (audio) {
         // audio.play();
        //}
      })
      .catch(error => {
        console.error(error);
        alert(error);
      });
    }
    function pollLobbyState() {
        fetch("http://127.0.0.1:8008/get_lobby_state", {
          method: "POST", // Or POST if your backend requires it
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            lobby_name: lobbyName,
          })
        })
        .then(response => {
          if (!response.ok) throw new Error("Failed to fetch lobby state.");
          return response.json();
        })
        .then(data => {
          // Update the game state div with the returned game state string
          document.getElementById("game-state-lobby").innerText = data.lobby_state;
        })
        .catch(error => console.error(error));
    }
    
    function revealHand() {
      // Set the hand display to visible
      document.getElementById("hand-display").style.display = "inline-block";
      updateHandDisplay();
    }

    function onRevealHandClick() {
      // fetch your personal hand & current event card from the server
      fetch("http://127.0.0.1:8008/get_game_state", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ lobby_name: lobbyName })
      })
      .then(r => r.json())
      .then(data => {
        const ec = data.game_state.event_card;
        // find your hand in the returned player_info
        const me = data.game_state.player_info.find(p=> p.username === userName);
        if (!me || !me.hand) return;
        // show exactly the same overlay as your play/click paths
        showHandDecisionOverlay(me.hand, 'discard', ec);
      })
      .catch(console.error);
    }

    function updateHandDisplay() {
      fetch("http://127.0.0.1:8008/get_game_state", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ lobby_name: lobbyName })
      })
      .then(r => r.json())
      .then(data => {
        const me = data.game_state.player_info.find(p=> p.username === userName);
        const playedCards = me ? (me.played_cards || []) : [];
        const handDisplay = document.getElementById("hand-display");
        handDisplay.innerHTML = "";
        // render each played card icon
        playedCards.forEach(card => {
          const img = document.createElement("img");
          img.src = cardImageMap[card] || "";
          img.alt = card;
          img.style.width = "40px";
          img.style.margin = "0 5px";
          handDisplay.appendChild(img);
        });
        // only show the “play area” if you’ve played something
        handDisplay.style.display = playedCards.length ? "inline-block" : "none";
      })
      .catch(console.error);
    }
    function formatNominationCounts(counts, players) {
        let html = 'Nomination Results:<br>';
        Object.entries(counts).forEach(([rawKey, cnt]) => {
          let label;
          // if key parses to an existing player_id, map to that username
          const id = Number(rawKey);
          const byId = players.find(p => p.player_id === id);
          if (!isNaN(id) && byId) {
            label = byId.username;
          }
          // treat explicit null/"None"/"null" as abstain
          else if (rawKey === 'None' || rawKey === 'null' || rawKey === "Unknown") {
            label = 'Abstain';
          }
          else {
            // otherwise assume it’s already a username
            label = rawKey;
          }
          html += `${label}: ${cnt} vote${cnt===1?'':'s'}<br>`;
        });
        return html;
    }
    ///////////////////////////////////////////////////////
    // Advance the Game State (MAIN GAME )
    //////////////////////////////////////////////////////
    function pollGameState() {
      fetch("http://127.0.0.1:8008/get_next_action", {
        method: "POST", // Or POST if your backend requires it
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          lobby_name: lobbyName,
        })
      })
      .then(response => {
        if (!response.ok) throw new Error("Failed to fetch game state.");
        return response.json();
      })
      .then(data => {
          // Assume data.event_card has 'prompt', 'plus_needed', and 'minus_needed'    
          let html = "";
          html += "<strong>" + data.summary + "</strong><br><br>";

          // display last played card (if exists)
          if (data.game_state && data.game_state.player_info) {
            let playedCards = [];
            data.game_state.player_info.forEach(player => {
              if (player.selected_card) {
                playedCards.push(player.selected_card);
              }
            });
            if (playedCards.length > 0) {
              html += "<br><div style='text-align:center;'>";
              html += "<strong>Cards Played:</strong> ";
              playedCards.forEach(card => {
                if (card === "+1") {
                  html += `<img src="assets/plus_card.png" alt="+" style="width:20px;height:auto; margin:0 5px;">`;
                } else {
                  html += `<img src="assets/minus_card.png" alt="-" style="width:20px;height:auto; margin:0 5px;">`;
                }
              });
              html += "</div>";
            }
          }
          turnPlayer = null;
          if (data.game_state && data.pending_actions) {
              data.pending_actions.forEach(msg => {
                const m = msg.match(/^Player (.+) must (?:discard|play) a card\.$/);
                if (m) turnPlayer = m[1];
              });
          }
          const lastPlayedDiv = document.getElementById("last-played-card");
          lastPlayedDiv.innerHTML = "";

          // Grab the *full* event’s played‐card list + your own played_cards
          const eventPlayed = data.game_state.event_played || [];
          const me          = data.game_state.player_info.find(p => p.username === userName);
          const myCards     = me ? (me.played_cards || []) : [];

          // For each card in the event, face‐up if you played it, else face‐down
          eventPlayed.forEach(key => {
              const img = document.createElement("img");
              img.src   = myCards.includes(key)
                          ? cardImageMap[key]               // your actual card
                          : "assets/minus_card.png";        // face-down
              img.alt     = key;
              img.style.width  = "40px";
              img.style.margin = "0 3px";
              lastPlayedDiv.appendChild(img);
          });

          lastPlayedDiv.style.display = eventPlayed.length
            ? "inline-block"
            : "none";
          console.log('Msg: ' + data.pending_actions + ' Turn : ' + turnPlayer)
          const turnIndicator = document.getElementById("turn-indicator");
          const revealBtn = document.getElementById("reveal-hand-btn");
          // If it’s someone’s turn to play a card…
          if (turnPlayer) {
              if (turnPlayer === userName) {
                  turnIndicator.innerText = "It’s your turn to play a card →";
                  revealBtn.style.display = "";
                  revealBtn.classList.add("glow");
              } else {
                  turnIndicator.innerText = `${turnPlayer}’s turn to play a card.`;
                  revealBtn.style.display = "none";
                  revealBtn.classList.remove("glow");
              }
          } else {
              // discussion, voting, etc.
              turnIndicator.innerText = "No card play required";
              revealBtn.style.display = "none";
              revealBtn.classList.remove("glow");
          }
          if (cardPlayed || justDiscarded) {
              const turnIndicator = document.getElementById("turn-indicator");
              const revealBtn = document.getElementById("reveal-hand-btn");
              turnIndicator.innerText = "No card play required";
              revealBtn.style.display = "none";
              revealBtn.classList.remove("glow");
          }
          // update mission and event number
          if (data.game_state) {
              //check if game over
              if (data.game_state.game_over === true) {
                  // Build the game over overlay content.
                  if (!alertedGameOver && alertedLastEvent) { // && !is_ai_player) {
                      let players = data.game_state.player_info;
                      let maxScore = Math.max(...players.map(p => p.score));
                      let gameOverHTML = "<div style='display: flex; flex-wrap: wrap; justify-content: center;'>";
                      players.forEach(p => {
                          // Construct the asset path – change this if needed.
                          let avatarPath = "assets/" + (p.avatar ? p.avatar : p.username.toLowerCase()) + ".png";
                          let winnerMarkup = "";
                          if (p.score === maxScore) {
                              winnerMarkup = "<div style='font-size: 1.8rem; font-weight: bold; color: yellow;'>Winner!</div>";
                          }
                          gameOverHTML += `<div style="margin: 10px; text-align: center;">
                                              <img src="${avatarPath}" alt="${p.username}" style="width: 80px; height: 80px; border: 2px solid #fff; border-radius: 50%;">
                                              <div>${p.username}</div>
                                              <div>Score: ${p.score}</div>
                                              ${winnerMarkup}
                                            </div>`;
                      });
                      gameOverHTML += "</div>";
                      showGameOverOverlay(gameOverHTML);
                      alertedGameOver = true;
                  }
              }
              // If your mission state includes completed_events and total_events, then:
              totalMissions = data.game_state.total_missions;
              // Determine current event number: count the event_results if available.
              let totalEvents = data.game_state.total_events || "";
              let currentEventNum = data.game_state.current_event_idx; //temp
              let currentMissionNum = data.game_state.mission_id;  //temp

              document.getElementById("mission-event-display").innerText =  "Mission: " + currentMissionNum + " / " + totalMissions + ",  Event: " + currentEventNum + " / " + totalEvents;
          }
          console.log('Event ID (front end): '+eventNum+' (backend): '+data.game_state.current_event_idx)
          console.log('Mission ID (front end): '+missionNum+' (backend): '+data.game_state.mission_id)
          console.log('Event clicked: ' + alertedLastEvent + ", Mission over clicked: " + alertedLastMissionOver + ", New Mission: " + alertedLastMission)
          // Event Over -- Show Overlay
          if ((data.game_state.current_event_idx > eventNum) && !alertedLastEvent) {
              /* Event results look like
                event_result = {
                  'event_card': self.current_event,
                  'event_played': self.event_played,
                  'event_hand': self.event_hand,
                  'event_success_count': self.coop_scores,
                  'event_fail_count': self.defector_scores,
                  'vote_result': self.vote_result ,
                  'yes_vote_ids': self.yes_vote_ids,
                  'nomination_results': nomination,
                  'mission_id': self.mission_id
                  }
              */
              console.log('Event over, showing overlay 1')
              console.log("state event: " + data.game_state.current_event_idx + ", FrontEvent: "+eventNum)
              console.log('Event Overlay: ' + missionNum + ": made it to chamber " + eventNum)
              let event_results = data.game_state.event_results;
              console.log('getting results of event idx' + eventNum-1)
              console.log(event_results)
              let last_event = event_results[eventNum-1];
              let coopCardsPlayed = last_event.event_success_count
              let defectorCardsPlayed = last_event.event_fail_count
              let retreatVoteResult = last_event.vote_result
              let event_mission_id = last_event.mission_id
              console.log("last event: " + last_event)
              let text = "Event " + eventNum + "<br>";
              text += "Cooperator Score: " + coopCardsPlayed +"<br>";
              text += "Defector Score: " + defectorCardsPlayed +"<br><br>";
              if (retreatVoteResult == 'yes') {
                  text += "The party voted to retreat!"
              } else {
                  text += "The party has voted not to retreat!"
              }
              showEventEndOverlay(text);
              eventNum = data.game_state.current_event_idx;
          }
          // Mission Over -- Show Overlay
          if (data.game_state.mission_id > missionNum) { // && !is_ai_player) {
              if (!alertedLastEvent) {
                  console.log('Event over, showing Event overlay 2')
                  console.log("state event: " + data.game_state.current_event_idx + ", FrontEvent: "+eventNum)
                  console.log('Event Overlay: ' + missionNum + ": made it to chamber " + eventNum)
                  let event_results = data.game_state.full_event_history;
                  console.log('event_results: ' + event_results)
                  let last_event = event_results[event_results.length-1];
                  console.log('Last event: ' + last_event)
                  let coopCardsPlayed = last_event.event_success_count
                  let defectorCardsPlayed = last_event.event_fail_count
                  let retreatVoteResult = last_event.vote_result
                  let event_mission_id = last_event.mission_id
                  let text = "Final Event <br>";
                  text += "Cooperator Score: " + coopCardsPlayed +"<br>";
                  text += "Defector Score: " + defectorCardsPlayed +"<br><br>";
                  if (retreatVoteResult == 'yes') {
                      text += "The party voted to retreat!"
                  } else {
                      text += "The party has voted not to retreat!"
                  }
                  showEventEndOverlay(text);
                  eventNum = data.game_state.current_event_idx;
              }
              /*
              mission_end_state = {
                'cooperator_found': cooperator_found,
                'defector_found': defector_found,
                'sabotage_successful': sabotage_successful,
                'mission_complete': mission_complete
              }*/
              if (alertedLastEvent && !alertedLastMissionOver && !alertedLastMission) {
                  console.log('New Mission, showing EndMission overlay')
                  let event_results = data.game_state.full_event_history;
                  let last_event = event_results[event_results.length-1];
                  let mission_results = data.game_state.mission_history;
                  let last_mission = mission_results[mission_results.length-1];
                  let mission_success = last_mission.mission_complete;
                  let sabotage_successful = last_mission.sabotage_successful;
                  let cooperator_found = last_mission.cooperator_found;
                  let defector_found = last_mission.defector_found;
                  let missionText = "Mission Complete <br>";
                  
                  const nomHTML = formatNominationCounts(last_event.nomination_counts, data.game_state.player_info);

                  if (defector_found === null) {
                      defector_found = 'false'
                  }
                  missionText += nomHTML;
                  if (mission_success) {
                    missionText += "Mission Outcome: Success! <br>";
                  } else {
                      missionText += "Mission Outcome: FAIL <br>";
                  }
                  missionText += "Cooperator Found: " + cooperator_found + "<br>";
                  missionText += "Defector Found: " + defector_found + "<br>";
                  missionText += "Mission Sabotaged: " + sabotage_successful;
                  // Show the overlay with mission text and payoff matrix:
                  showMissionOverlay(missionText, false);
                  document.getElementById("game-role-selection").style.display = "";
                  // hide last played card and hand details
                  const lastPlayedDiv = document.getElementById("last-played-card");
                  lastPlayedDiv.innerHTML = "";  // clear previous contents
                  lastPlayedDiv.style.display = "none";
                  document.getElementById("hand-display").style.display = "none";
                  document.getElementById("reveal-hand-btn").style.display = "";
                  document.getElementById("game-role-cooperator").classList.remove("selected");
                  document.getElementById("game-role-defector").classList.remove("selected");
              }
              
              if (alertedLastEvent && alertedLastMissionOver && !alertedLastMission) {
                  console.log('New Mission, showing overlay')
                  let missionText = data.game_state.mission_text || "No mission yet.";
                  showMissionOverlay(missionText, true);
                  eventNum = 1
                  missionNum = data.game_state.mission_id;
                  currentRole = ""
                  // alertedLastMission = true;
              }
          }
          // handle game phases/actions returned by backend
          if (data.pending_actions.length > 0) {
              data.pending_actions.forEach(msg => {
                if (msg.includes("select a role") && msg.includes(userName)) {
                    console.log(msg)
                    alertedNomination = false;
                    if (!rolesSet) {
                        document.getElementById("game-role-selection").style.display = "";
                    }
                } 
                else if (msg.includes("play a card") && msg.includes(userName) ) {
                    rolesSet = false;
                    let phand = ""
                    alertedRetreat = false;
                    const ec = data.game_state.event_card;
                    data.game_state.player_info.forEach(player => {
                        if (player.username == userName) {
                            phand = player.hand;
                        }
                    });
                    console.log("PLAYCARD. showing overlay with hand: " + phand);
                    if (justDiscarded) {
                        showHandDecisionOverlay(phand, 'post-discard', ec);
                        justDiscarded = false;
                    } //else {
                    //    showHandDecisionOverlay(phand, 'play', ec);
                    //}
                }
                else if (msg.includes("discard") && msg.includes(userName) ) {
                    let phand = "";
                    alertedRetreat = false;
                    const ec = data.game_state.event_card;
                    data.game_state.player_info.forEach(player => {
                        if (player.username == userName) {
                            phand = player.hand;
                        }
                    });
                    console.log("DISCARD");           
                }
                else if (msg.includes("nominate")) {
                    alertedRetreat = false;
                    alertedLastEvent = false;  // safe place to re-enable alert
                    alertedLastMission = false;
                    alertedLastMissionOver = false;
                    cardPlayed = false;
                    justDiscarded = false;
                    console.log("NOMINATE action pending for player(s).");
                    if (data.game_state && data.game_state.player_info) {
                        console.log('showing nomination dropdown')
                        if (!alertedNomination) {
                            showNominationDropdown(data.game_state.player_info)
                        }
                    }
                } 
                else if (msg.includes("vote")) {
                    alertedLastEvent = false;  // safe place to re-enable alert
                    alertedLastMission = false;
                    alertedLastMissionOver = false;
                    cardPlayed = false;
                    justDiscarded = false;
                    console.log('Vote game state: ' + data.game_state.event_played)
                    if (!alertedRetreat) {
                        showRetreatOverlay(data.game_state.event_played, data.game_state.event_card);
                    }  
                } 
                else if (msg.includes("complete")) {
                  console.log('Event complete -- going to next phase')
                  // clear elements
                  missionComplete = true;
                }        
              });
          }
          if (data.game_state && data.game_state.event_card && currentRole !== "") {
              const ec = data.game_state.event_card;
            
              // 1) Prompt
              html += `<div style="margin-top:10px;"><strong>Event:</strong> ${ec.prompt}</div>`;
              html += '<br><strong>Attribute requirements for this event:</strong> '
              if (ec.attribute_slots) {
                html += `<div id="event-requirement-cards" style="display:flex;justify-content:center;gap:10px;margin:10px 0;">`;
              
                Object.entries(ec.attribute_slots)
                      .forEach(([card, count]) => {
                  if (count === 0) return;
                  const role = count > 0 ? "coop" : "def";
                  const times = Math.abs(count);
                  for (let i = 0; i < times; i++) {
                    html += `
                      <div style="text-align:center;">
                        <img
                          src="${cardImageMap[card]}"
                          class="hand-card-${role}"
                          style="width:50px;"
                        >
                        <div style="font-size:0.8rem;">${cardAttrMap[card]}</div>
                      </div>`;
                  }
                });
              
                html += `</div>`;
              }
              /*// 2) Human‐readable requirement string (slot_string comes straight from EventCard.__repr__)
              if (ec.slot_string) {
                html += `<div style="margin-top:8px; font-style:italic; text-align:left;">${ec.slot_string}</div>`;
              }
              // (fallback in case slot_string isn’t sent—uses raw attribute_slots)
              else if (ec.attribute_slots) {
                html += `<ul style="margin-top:8px; text-align:left;">`;
                for (const [attr, count] of Object.entries(ec.attribute_slots)) {
                  if (count > 0) {
                    html += `<li>Cooperators need ${count}×<code>${attr}</code></li>`;
                  } else if (count < 0) {
                    html += `<li>Defectors need ${Math.abs(count)}×<code>${attr}</code></li>`;
                  }
                }
                html += `</ul>`;
              }*/
          }
          document.getElementById("game-state-display").innerHTML = html;
      })
      .catch(error => console.error(error));
    }
    // NOMINATION FUNCTIONS
    function nominatePlayer(nominatedUsername) {
        fetch("http://127.0.0.1:8008/set_nomination", {
          method: "POST", // Or POST if your backend requires it
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            lobby_name: lobbyName,
            username: userName,
            nomination: nominatedUsername
          })
        })
        .then(response => {
          if (!response.ok) throw new Error("Failed to fetch game state.");
          return response.json();
        })
        .catch(error => console.error(error));

    }
    function showNominationDropdown(playerInfo) {
      // Only create the dropdown if it does not already exist.
      if (document.getElementById("nomination-dropdown-container")) {
        return;
      }
      console.log("showNominationDropdown");
      let container = document.createElement("div");
      container.id = "nomination-dropdown-container";
      container.style.textAlign = "center";
      container.style.marginTop = "10px";
      container.style.padding = "10px";
      container.style.border = "2px solid #fff";
      container.style.backgroundColor = "#2d2d6f";
      container.style.display = "block"; // Ensure it's displayed
    
      container.innerHTML = "<h4>Who is the Defector?<br>Select a player to nominate or abstain:</h4>";
      let select = document.createElement("select");
      select.id = "nomination-select";
      // Default option
      let defaultOption = document.createElement("option");
      defaultOption.value = "";
      defaultOption.text = "-- Select player --";
      select.appendChild(defaultOption);
    
      // Populate options (excluding self assuming current user is the leader)
      playerInfo.forEach(p => {
          if (p.username !== userName) {
              let option = document.createElement("option");
              option.value = p.player_id;
              option.text = p.username;
              select.appendChild(option);
          }
      });
      let option = document.createElement("option");
      option.value = "Abstain";
      option.text =  "Abstain";
      select.appendChild(option)
      container.appendChild(select);
    
      // Create a confirm nomination button.
      let confirmBtn = document.createElement("button");
      confirmBtn.innerText = "Nominate";
      confirmBtn.style.marginLeft = "10px";
      confirmBtn.onclick = function() {
          let selectedValue = select.value;
          if (!selectedValue) {
              alert("Please select a nomination option.");
              return;
          }
          if (selectedValue === 'Abstain') {
            console.log('Abstained from voting')
            nominatePlayer('Unknown')
          } else {
            let nominatedPlayer = playerInfo.find(p => p.player_id == selectedValue);
            console.log("Nomination confirmed for:", nominatedPlayer.username);
            nominatePlayer(nominatedPlayer.username);
          }
          container.remove();
          alertedNomination = true;
      };
      container.appendChild(confirmBtn);
    
      // Append the container to a dedicated container that isn’t overwritten.
      let nomContainer = document.getElementById("nomination-ui-container");
      if (nomContainer) {
        nomContainer.appendChild(container);
      } else {
        console.error("Nomination UI container not found.");
      }
    }
    // VOTING FUNCTIONS
    function votePlayer(vote) {
      fetch("http://127.0.0.1:8008/set_vote", {
        method: "POST", // Or POST if your backend requires it
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          lobby_name: lobbyName,
          username: userName,
          vote: vote
        })
      })
      .then(response => {
        if (!response.ok) throw new Error("Failed to fetch game state.");
        return response.json();
      })
      .catch(error => console.error(error));

  }
    function showVotingDropdown(nominatedPlayer) {
        // Only create the dropdown if it does not already exist.
        if (document.getElementById("voting-dropdown-container")) {
          return;
        }
        console.log("showVotingDropdown");
        let container = document.createElement("div");
        container.id = "voting-dropdown-container";
        container.style.textAlign = "center";
        container.style.marginTop = "10px";
        container.style.padding = "10px";
        container.style.border = "2px solid #fff";
        container.style.backgroundColor = "#2d2d6f";
        container.style.display = "block";
        // Show header with the nominated player's username (and optionally avatar)
        container.innerHTML = `<h4>Vote on: ${nominatedPlayer.username}</h4>`;
        // Create a dropdown with "Yes" and "No" options.
        let select = document.createElement("select");
        select.id = "voting-select";
        // Default option.
        let defaultOption = document.createElement("option");
        defaultOption.value = "";
        defaultOption.text = "-- Vote --";
        select.appendChild(defaultOption);
        // Option: Yes.
        let yesOption = document.createElement("option");
        yesOption.value = "yes";
        yesOption.text = "Yes";
        select.appendChild(yesOption);
        // Option: No.
        let noOption = document.createElement("option");
        noOption.value = "no";
        noOption.text = "No";
        select.appendChild(noOption);
        container.appendChild(select);
      
        // Create a confirm voting button (no confirmation alert).
        let confirmBtn = document.createElement("button");
        confirmBtn.innerText = "Confirm Vote";
        confirmBtn.style.marginLeft = "10px";
        confirmBtn.onclick = function() {
          let selectedValue = select.value;
          if (!selectedValue) {
            alert("Please select 'Yes' or 'No'.");
            return;
          }
          console.log("Voting confirmed:", selectedValue, "for", nominatedPlayer.username);
          votePlayer(selectedValue);  // Send the vote (either "yes" or "no")
          container.remove();
        };
        container.appendChild(confirmBtn);
      
        // Append the voting UI to a dedicated container.
        let voteContainer = document.getElementById("voting-ui-container");
        if (voteContainer) {
          voteContainer.appendChild(container);
          console.log("Voting dropdown appended:", container.outerHTML);
        } else {
          console.error("Voting UI container not found.");
        }
    }  
    // pokemon
    function toggleAudio() {
        let audio = document.getElementById("theme-audio");
        let toggleBtn = document.getElementById("audio-toggle");
        if (audio.paused) {
            audio.play();
            toggleBtn.innerText = "Pause";
        } else {
            audio.pause();
            toggleBtn.innerText = "Play";
        }
    }
    // Hide the event end overlay.

    // Attach an event handler to the "Continue" button to hide the overlay.
    document.getElementById("continue-event-btn").onclick = function() {
      hideEventEndOverlay();
      alertedLastEvent = true;
    };
    //mission overlay
    function formatPayoffMatrix(payoffMatrix) {
      let html = "<table style='margin: auto; border-collapse: collapse;'>";
      for (let key in payoffMatrix) {
        if (payoffMatrix.hasOwnProperty(key)) {
          html += `<tr style='border: 1px solid #fff;'>
                     <td style='padding: 5px; font-weight:bold;'>${key}</td>
                     <td style='padding: 5px;'>${payoffMatrix[key]}</td>
                   </tr>`;
        }
      }
      html += "</table>";
      return html;
    }
    function showEventEndOverlay(summaryText) {
        console.log("Showing event end overlay with summary:", summaryText);
        document.getElementById("event-summary").innerHTML = summaryText;
        let overlay = document.getElementById("event-overlay");
        overlay.style.display = "flex";
        overlay.style.alignItems = "center";
        overlay.style.justifyContent = "center";
        overlay.style.zIndex = "1001";
    }
    function hideEventEndOverlay() {
        document.getElementById("event-overlay").style.display = "none";
        alertedLastEvent = true;
    }
    function showMissionOverlay(summaryText, text) {
        console.log("Showing mission overlay with summary:", summaryText);
        if (text == true) {
            document.getElementById("mission-text").innerText = summaryText;
        } else {
            document.getElementById("mission-text").innerHTML = summaryText;
        }  
        let overlay = document.getElementById("mission-overlay");
        overlay.style.display = "flex";
        overlay.style.alignItems = "center";
        overlay.style.justifyContent = "center";
        overlay.style.zIndex = "1000";
    }
    function hideMissionOverlay() {
        document.getElementById("mission-overlay").style.display = "none";
    }
    function showGameOverOverlay(summaryText) {
        console.log("Showing game over overlay with summary:", summaryText);
        document.getElementById("gameover-summary").innerHTML = summaryText;
        let overlay = document.getElementById("gameover-overlay");
        overlay.style.display = "flex";
        overlay.style.alignItems = "center";
        overlay.style.justifyContent = "center";
        overlay.style.zIndex = "1000";
    }

    function showHandDecisionOverlay(hand, mode, ec) {
      _selectedHandCard = null;
    
      const overlay    = document.getElementById('hand-overlay');
      const headingEl  = overlay.querySelector('#hand-decision-content h2');
      const opts       = document.getElementById('hand-options');
      const playBtn    = document.getElementById('hand-play-btn');
      const discBtn    = document.getElementById('hand-discard-btn');
      console.log('in overlay with mode: ' + mode)
      // 1) set the heading text
      if (mode === 'discard') {
        headingEl.innerText = 'Select a card to Play or Discard';
      } else if (mode === 'post-discard') {
        headingEl.innerText = 'Card Discarded\nChoose from two new cards to play';
      } else {
        headingEl.innerText = 'Select a card to play';
      }
    
      // 2) clear out old cards & listeners
      opts.innerHTML = '';
      playBtn.replaceWith(playBtn.cloneNode(true));
      discBtn.replaceWith(discBtn.cloneNode(true));
    
      // grab fresh references
      const newPlayBtn = document.getElementById('hand-play-btn');
      const newDiscBtn = document.getElementById('hand-discard-btn');
    
      // 3) render the two new cards
      // 3) Render each card with border class
      hand.forEach(card => {
          const img = document.createElement('img');
          img.src         = cardImageMap[card] || '';
          img.alt         = card;
          img.dataset.card = card;
          img.style.cursor = 'pointer';
          img.style.width  = '60px';

          // decide coop vs defect
          const slotValue = ec.attribute_slots[card] || 0;
          img.classList.add(slotValue > 0 ? 'hand-card-coop' : 'hand-card-def');

          img.onclick = () => {
              _selectedHandCard = card;
              opts.querySelectorAll('img').forEach(i => i.classList.remove('selected'));
              img.classList.add('selected');
          };
          opts.appendChild(img);
      });

    
      // 4) show/hide buttons & wire them up
      if (mode === 'discard') {
        newPlayBtn.style.display = '';
        newDiscBtn.style.display = '';
        newDiscBtn.onclick = () => {
          if (!_selectedHandCard) return alert('Pick one first');
          fetch("http://127.0.0.1:8008/discard_card", {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({
              lobby_name: lobbyName,
              username:   userName,
              card:       _selectedHandCard,
              is_discard: true
            })
          })
          .then(_ => {
            console.log('hiding card turn elements')
            const turnIndicator = document.getElementById("turn-indicator");
            const revealBtn = document.getElementById("reveal-hand-btn");
            turnIndicator.innerText = "No card play required";
            revealBtn.style.display = "none";
            revealBtn.classList.remove("glow");
            hideHandDecisionOverlay();
            justDiscarded = true;
          })
          .catch(console.error);
        };
        newPlayBtn.onclick = () => {
          if (!_selectedHandCard) return alert('Pick one first');
          fetch("http://127.0.0.1:8008/discard_card", {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({
              lobby_name: lobbyName,
              username:   userName,
              card:       _selectedHandCard,
              is_discard: false
            })
          })
          .then(_ => {
            console.log('hiding card turn elements')
            const turnIndicator = document.getElementById("turn-indicator");
            const revealBtn = document.getElementById("reveal-hand-btn");
            turnIndicator.innerText = "No card play required";
            revealBtn.style.display = "none";
            revealBtn.classList.remove("glow");
            hideHandDecisionOverlay();
            cardPlayed = true;
          })
          .catch(console.error);
        };
      }
      else {
        // both 'play' and 'post-discard' modes call /play_card
        newDiscBtn.style.display = 'none';
        newPlayBtn.style.display = '';
        newPlayBtn.onclick = () => {
          if (!_selectedHandCard) return alert('Pick one first');
          fetch("http://127.0.0.1:8008/play_card", {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({
              lobby_name: lobbyName,
              username:   userName,
              card:       _selectedHandCard
            })
          })
          .then(_ => {
              console.log('hiding card turn elements')
              const turnIndicator = document.getElementById("turn-indicator");
              const revealBtn = document.getElementById("reveal-hand-btn");
              turnIndicator.innerText = "No card play required";
              revealBtn.style.display = "none";
              revealBtn.classList.remove("glow");
              hideHandDecisionOverlay();
          })
          .catch(console.error);
        };
      }
    
      overlay.style.display = 'flex';
    }

    function hideHandDecisionOverlay() {
       document.getElementById('hand-overlay').style.display = 'none';
       updateHandDisplay();

    }
    document.getElementById("enter-mission-btn").onclick = function() {
        hideMissionOverlay();
        if (!alertedLastMissionOver) {
            alertedLastMissionOver = true
        }
        else {
          alertedLastMission = true;
        } 
    };  
    // RETREAT
    function showRetreatOverlay(playedKeys, ec) {
        const container = document.getElementById('retreat-cards');
        container.innerHTML = '';
        console.log('Retreat played cards: ', + playedKeys)
        playedKeys.forEach(key => {
          const img = document.createElement('img');
          img.src = cardImageMap[key] || '';
          img.alt = key;
          // determine role‐color: if it’s the primary cooperator card, or any attr_slots>0 → cooperator
          const isCoop = key === ec.primary_coop
                        || (ec.attribute_slots[key] != null && ec.attribute_slots[key] > 0);
          img.classList.add('retreat-card', isCoop ? 'coop' : 'def');
          container.appendChild(img);
        });
        document.getElementById('retreat-overlay').style.display = 'flex';
        console.log('In retreat overlay, waiting for decision')
    }
    document.getElementById('retreat-btn').onclick = () => {
      console.log('Voted to RETREAT, new mission SHOULD start')
      fetch("http://127.0.0.1:8008/set_retreat", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({
          lobby_name: lobbyName,
          username:  userName,
          retreat:   true
        })
      }).then(() => hideRetreatOverlay())
        .catch(console.error);
    };
    document.getElementById('keepgoing-btn').onclick = () => {
      console.log('Voted to NOT RETREAT, new event should start')
      fetch("http://127.0.0.1:8008/set_retreat", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({
          lobby_name: lobbyName,
          username:  userName,
          retreat:   false
        })
      }).then(() => hideRetreatOverlay())
        .catch(console.error);
    };
    function hideRetreatOverlay() {
        document.getElementById('retreat-overlay').style.display = 'none';
        alertedRetreat = true;
    }
    // Hide the game over overlay.
    function hideGameOverOverlay() {
      document.getElementById("gameover-overlay").style.display = "none";
      alertedGameOver = true;
    }
    // When the user clicks "Back to Lobby", hide the overlay and navigate to the Lobby tab.
    function backToLobby() {
      hideGameOverOverlay();
      reset_frontend_newgame()
      is_ready = false;
      quitGame()
      showTab("lobby");
      // Optionally refresh or reset any necessary state.
    }
    // When the user clicks "Start New Game", hide the overlay and initiate a new game.
    function startNewGame() {
      hideGameOverOverlay();
      reset_frontend_newgame()
      let restart = true;
      startGame(restart);
    }
  
      // 1) model names in four rows
    const aiModels = [
        ["o3-mini","o4-mini","gpt-4.1","gpt-4.5","gpt-4o","claude-3.7","claude-3.5"],
        ["gemma2","gemma3","gemini-2.5","gemini-2","gemini-2.5","olmo-2","deephermes3"],
        ["qwen-2","qwen-2.5","qwq","grok-2","grok-3","mistral-small","mistral-large"],
        ["llama-3.1","llama-3.3","llama-4","deepseek-r1","deepseek-distilled"],
    ];
    document.getElementById("add-ai-player-btn")
    .addEventListener("click", () => {
      const cfg = document.getElementById("ai-player-config");
      cfg.style.display = cfg.style.display === "block" ? "none" : "block";
      if (cfg.style.display === "block" && !cfg.dataset.populated) {
        populateAIGrid();
        cfg.dataset.populated = "true";
      }
    });
    // ---- build grid with real avatars ----
    function populateAIGrid() {
      const grid = document.getElementById("ai-avatar-grid");
      aiModels.forEach(row => {
        row.forEach(model => {
          const div = document.createElement("div");
          div.className = "ai-avatar";
          const img = document.createElement("img");
          img.src = `assets/${model}.png`;
          img.alt = model;
          img.style.width = "100%";
          img.style.height = "auto";
          const label = document.createElement("div");
          label.textContent = model;
          label.style.marginTop = "2px";
          label.style.fontSize = "0.5rem";
          div.appendChild(img);
          div.appendChild(label);
          div.dataset.model = model;
          div.onclick = () => selectAIAvatar(div);
          grid.appendChild(div);
        });
      });
    }

    function selectAIAvatar(div) {
      // clear previous highlight
      document.querySelectorAll(".ai-avatar.selected")
              .forEach(d => d.classList.remove("selected"));
      div.classList.add("selected");
      selectedModel = div.dataset.model;
      // show controls area
      const area = document.getElementById("ai-controls-area");
      area.style.display = "block";
      area.style.width = "90%"
      // reset slider & label
      selectedTemp = 0.7;
      const slider = document.getElementById("ai-temp-slider");
      const label  = document.getElementById("ai-temp-label");
      slider.value = selectedTemp;
      label.textContent = `Temp: ${selectedTemp}`;
      slider.style.display = "none";
      label.style.display = "none";
    }

    // ---- Configure btn toggles slider ----
    document.getElementById("ai-configure-btn").addEventListener("click", () => {
        const slider = document.getElementById("ai-temp-slider");
        const label  = document.getElementById("ai-temp-label");
        if (slider.style.display === "none") {
            slider.style.display = "block";
            label.style.display  = "block";
        } else {
            slider.style.display = "none";
            label.style.display  = "none";
        }
    });
    
    // ---- slider update ----
    document.getElementById("ai-temp-slider").addEventListener("input", e => {
        selectedTemp = e.target.value;
        document.getElementById("ai-temp-label").textContent = `Temp: ${selectedTemp}`;
    });
    
    // ---- Add AI btn ----
    document.getElementById("ai-add-btn").addEventListener("click", () => {
        const url = document.getElementById("ai-url").value.trim();
        const apiKey = document.getElementById("ai-apiKey").value.trim();
        const systemPrompt = document.getElementById("ai-sysprompt").value.trim();
        if (!selectedModel) return alert("Pick a model first");
        if (!url) return alert("Enter AI URL");
        addBot(selectedModel, selectedTemp, apiKey, systemPrompt, url);
    });
  
  </script>
</body>
</html>